package middleware

import (
	"net/http"
	"net/http/httptest"
	"os"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
)

func TestCORSMiddleware(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tests := []struct {
		name                    string
		origin                  string
		corsAllowedOrigins      string
		expectedAllowOrigin     string
		expectedAllowCredentials string
		shouldHaveOriginHeader  bool
	}{
		{
			name:                   "allowed origin should get CORS headers",
			origin:                 "http://localhost:3000",
			corsAllowedOrigins:     "http://localhost:3000,http://localhost:3001",
			expectedAllowOrigin:    "http://localhost:3000",
			expectedAllowCredentials: "true",
			shouldHaveOriginHeader: true,
		},
		{
			name:                   "disallowed origin should NOT get Access-Control-Allow-Origin header",
			origin:                 "http://malicious-site.com",
			corsAllowedOrigins:     "http://localhost:3000,http://localhost:3001",
			expectedAllowOrigin:    "",
			expectedAllowCredentials: "",
			shouldHaveOriginHeader: false,
		},
		{
			name:                   "empty origin should not get CORS headers",
			origin:                 "",
			corsAllowedOrigins:     "http://localhost:3000",
			expectedAllowOrigin:    "",
			expectedAllowCredentials: "",
			shouldHaveOriginHeader: false,
		},
		{
			name:                   "no CORS_ALLOWED_ORIGINS env should use defaults",
			origin:                 "http://localhost:3000",
			corsAllowedOrigins:     "",
			expectedAllowOrigin:    "http://localhost:3000",
			expectedAllowCredentials: "true",
			shouldHaveOriginHeader: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Set up environment
			if tt.corsAllowedOrigins != "" {
				os.Setenv("CORS_ALLOWED_ORIGINS", tt.corsAllowedOrigins)
			} else {
				os.Unsetenv("CORS_ALLOWED_ORIGINS")
			}

			// Create test router
			router := gin.New()
			router.Use(CORSMiddleware())
			router.GET("/test", func(c *gin.Context) {
				c.JSON(http.StatusOK, gin.H{"message": "test"})
			})

			// Create request
			req, _ := http.NewRequest("GET", "/test", nil)
			if tt.origin != "" {
				req.Header.Set("Origin", tt.origin)
			}

			// Record response
			w := httptest.NewRecorder()
			router.ServeHTTP(w, req)

			// Verify response
			assert.Equal(t, http.StatusOK, w.Code)

			// Check CORS headers
			if tt.shouldHaveOriginHeader {
				assert.Equal(t, tt.expectedAllowOrigin, w.Header().Get("Access-Control-Allow-Origin"))
				assert.Equal(t, tt.expectedAllowCredentials, w.Header().Get("Access-Control-Allow-Credentials"))
			} else {
				// Critical security test: ensure Access-Control-Allow-Origin is NOT set for disallowed origins
				assert.Empty(t, w.Header().Get("Access-Control-Allow-Origin"), "Access-Control-Allow-Origin should not be set for disallowed origins")
				assert.Empty(t, w.Header().Get("Access-Control-Allow-Credentials"))
			}

			// Vary header should always be present
			assert.Contains(t, w.Header().Get("Vary"), "Origin")
		})
	}
}

func TestCORSMiddlewarePreflightRequest(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tests := []struct {
		name               string
		origin             string
		corsAllowedOrigins string
		shouldHaveCORSHeaders bool
	}{
		{
			name:               "preflight with allowed origin should get CORS headers",
			origin:             "http://localhost:3000",
			corsAllowedOrigins: "http://localhost:3000",
			shouldHaveCORSHeaders: true,
		},
		{
			name:               "preflight with disallowed origin should NOT get CORS headers",
			origin:             "http://malicious-site.com",
			corsAllowedOrigins: "http://localhost:3000",
			shouldHaveCORSHeaders: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Set up environment
			os.Setenv("CORS_ALLOWED_ORIGINS", tt.corsAllowedOrigins)

			// Create test router
			router := gin.New()
			router.Use(CORSMiddleware())
			router.OPTIONS("/test", func(c *gin.Context) {
				// This should not be reached due to middleware handling
				c.JSON(http.StatusOK, gin.H{"message": "options"})
			})

			// Create preflight request
			req, _ := http.NewRequest("OPTIONS", "/test", nil)
			req.Header.Set("Origin", tt.origin)
			req.Header.Set("Access-Control-Request-Method", "POST")

			// Record response
			w := httptest.NewRecorder()
			router.ServeHTTP(w, req)

			// Preflight should return 204 No Content
			assert.Equal(t, http.StatusNoContent, w.Code)

			if tt.shouldHaveCORSHeaders {
				assert.Equal(t, tt.origin, w.Header().Get("Access-Control-Allow-Origin"))
				assert.NotEmpty(t, w.Header().Get("Access-Control-Allow-Methods"))
				assert.NotEmpty(t, w.Header().Get("Access-Control-Allow-Headers"))
			} else {
				// Critical: disallowed origins should not get CORS headers even for preflight
				assert.Empty(t, w.Header().Get("Access-Control-Allow-Origin"))
			}
		})
	}
}

func TestIsOriginAllowed(t *testing.T) {
	allowedOrigins := []string{
		"http://localhost:3000",
		"https://example.com",
		"https://app.example.com",
	}

	tests := []struct {
		name     string
		origin   string
		expected bool
	}{
		{
			name:     "exact match should be allowed",
			origin:   "http://localhost:3000",
			expected: true,
		},
		{
			name:     "https exact match should be allowed",
			origin:   "https://example.com",
			expected: true,
		},
		{
			name:     "subdomain exact match should be allowed",
			origin:   "https://app.example.com",
			expected: true,
		},
		{
			name:     "different port should not be allowed",
			origin:   "http://localhost:3001",
			expected: false,
		},
		{
			name:     "different protocol should not be allowed",
			origin:   "https://localhost:3000",
			expected: false,
		},
		{
			name:     "malicious origin should not be allowed",
			origin:   "http://malicious-site.com",
			expected: false,
		},
		{
			name:     "empty origin should not be allowed",
			origin:   "",
			expected: false,
		},
		{
			name:     "null origin should not be allowed",
			origin:   "null",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := isOriginAllowed(tt.origin, allowedOrigins)
			assert.Equal(t, tt.expected, result)
		})
	}
}