package middleware

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"log"
	"time"

	"github.com/gin-gonic/gin"
)

// LoggingMiddleware creates a middleware for request logging
func LoggingMiddleware() gin.HandlerFunc {
	return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
		return fmt.Sprintf("%s - [%s] \"%s %s %s %d %s \"%s\" %s\"\n",
			param.ClientIP,
			param.TimeStamp.Format(time.RFC1123),
			param.Method,
			param.Path,
			param.Request.Proto,
			param.StatusCode,
			param.Latency,
			param.Request.UserAgent(),
			param.ErrorMessage,
		)
	})
}

// RequestIDMiddleware adds a unique request ID to each request
func RequestIDMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		requestID := c.GetHeader("X-Request-ID")
		if requestID == "" {
			requestID = generateRequestID()
		}
		c.Header("X-Request-ID", requestID)
		c.Set("request_id", requestID)
		c.Next()
	}
}

// generateRequestID generates a cryptographically secure unique request ID
func generateRequestID() string {
	// SECURITY: Use cryptographically secure random generation instead of predictable timestamps
	// This prevents request ID prediction attacks and ensures true uniqueness across concurrent requests
	// Using crypto/rand provides cryptographically secure randomness suitable for security-sensitive operations
	
	// Generate 16 bytes of random data (128 bits of entropy)
	randomBytes := make([]byte, 16)
	_, err := rand.Read(randomBytes)
	if err != nil {
		// Fallback: If crypto/rand fails, log the error but still generate a request ID
		// In production, consider failing the request or using a different approach
		log.Printf("WARNING: Failed to generate cryptographically secure request ID: %v", err)
		
		// Emergency fallback - use a fixed string to avoid predictable patterns
		// This should rarely happen as crypto/rand is very reliable
		// In production, consider returning an error or using alternative entropy sources
		return "fallback_entropy_unavailable"
	}
	
	// Convert to hex string for readability and URL safety
	// This produces a 32-character hex string with 128 bits of entropy
	return hex.EncodeToString(randomBytes)
}