package repositories

import (
	"fmt"

	"{{.Name}}/internal/models"
	"gorm.io/gorm"
)

// UserRepository defines the interface for user data operations
type UserRepository interface {
	Create(user *models.User) (*models.User, error)
	GetByID(id uint) (*models.User, error)
	GetByEmail(email string) (*models.User, error)
	GetByUsername(username string) (*models.User, error)
	Update(user *models.User) (*models.User, error)
	Delete(id uint) error
	List(offset, limit int) ([]*models.User, int64, error)
	AssignRole(userID, roleID uint) error
	RemoveRole(userID, roleID uint) error
}

// userRepository implements UserRepository
type userRepository struct {
	db *gorm.DB
}

// NewUserRepository creates a new user repository
func NewUserRepository(db *gorm.DB) UserRepository {
	return &userRepository{db: db}
}

// Create creates a new user with input validation and secure error handling
func (r *userRepository) Create(user *models.User) (*models.User, error) {
	// Input validation
	if user == nil {
		return nil, fmt.Errorf("user cannot be nil")
	}
	if user.Email == "" || user.Username == "" {
		return nil, fmt.Errorf("email and username are required")
	}

	// Use transaction for data consistency
	err := r.db.Transaction(func(tx *gorm.DB) error {
		return tx.Create(user).Error
	})
	
	if err != nil {
		// Return generic error to avoid information leakage
		return nil, fmt.Errorf("failed to create user")
	}
	
	return r.GetByID(user.ID)
}

// GetByID gets a user by ID with roles and permissions using parameterized queries
func (r *userRepository) GetByID(id uint) (*models.User, error) {
	// Input validation
	if id == 0 {
		return nil, fmt.Errorf("invalid user ID")
	}

	var user models.User
	err := r.db.Preload("Roles.Permissions").First(&user, id).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("user not found")
		}
		// Return generic error to avoid information leakage
		return nil, fmt.Errorf("database error occurred")
	}
	return &user, nil
}

// GetByEmail gets a user by email with roles and permissions using parameterized queries
func (r *userRepository) GetByEmail(email string) (*models.User, error) {
	// Input validation
	if email == "" {
		return nil, fmt.Errorf("email cannot be empty")
	}

	var user models.User
	err := r.db.Preload("Roles.Permissions").Where("email = ?", email).First(&user).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("user not found")
		}
		// Return generic error to avoid information leakage
		return nil, fmt.Errorf("database error occurred")
	}
	return &user, nil
}

// GetByUsername gets a user by username with roles and permissions using parameterized queries
func (r *userRepository) GetByUsername(username string) (*models.User, error) {
	// Input validation
	if username == "" {
		return nil, fmt.Errorf("username cannot be empty")
	}

	var user models.User
	err := r.db.Preload("Roles.Permissions").Where("username = ?", username).First(&user).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("user not found")
		}
		// Return generic error to avoid information leakage
		return nil, fmt.Errorf("database error occurred")
	}
	return &user, nil
}

// Update updates a user with input validation and secure error handling
func (r *userRepository) Update(user *models.User) (*models.User, error) {
	// Input validation
	if user == nil {
		return nil, fmt.Errorf("user cannot be nil")
	}
	if user.ID == 0 {
		return nil, fmt.Errorf("invalid user ID")
	}

	// Use transaction for data consistency
	err := r.db.Transaction(func(tx *gorm.DB) error {
		return tx.Save(user).Error
	})
	
	if err != nil {
		// Return generic error to avoid information leakage
		return nil, fmt.Errorf("failed to update user")
	}
	
	return r.GetByID(user.ID)
}

// Delete soft deletes a user with input validation and secure error handling
func (r *userRepository) Delete(id uint) error {
	// Input validation
	if id == 0 {
		return fmt.Errorf("invalid user ID")
	}

	// Use transaction for data consistency
	err := r.db.Transaction(func(tx *gorm.DB) error {
		// Verify user exists before deletion
		var user models.User
		if err := tx.First(&user, id).Error; err != nil {
			if err == gorm.ErrRecordNotFound {
				return fmt.Errorf("user not found")
			}
			return err
		}
		
		return tx.Delete(&models.User{}, id).Error
	})
	
	if err != nil {
		if err.Error() == "user not found" {
			return err
		}
		// Return generic error to avoid information leakage
		return fmt.Errorf("failed to delete user")
	}
	
	return nil
}

// List lists users with pagination and input validation
func (r *userRepository) List(offset, limit int) ([]*models.User, int64, error) {
	// Input validation
	if offset < 0 {
		return nil, 0, fmt.Errorf("offset cannot be negative")
	}
	if limit <= 0 || limit > 1000 {
		return nil, 0, fmt.Errorf("limit must be between 1 and 1000")
	}

	var users []*models.User
	var total int64

	// Count total users with error handling
	if err := r.db.Model(&models.User{}).Count(&total).Error; err != nil {
		return nil, 0, fmt.Errorf("failed to count users")
	}

	// Get users with pagination and secure error handling
	err := r.db.Preload("Roles.Permissions").
		Offset(offset).
		Limit(limit).
		Find(&users).Error

	if err != nil {
		return nil, 0, fmt.Errorf("failed to retrieve users")
	}

	return users, total, nil
}

// AssignRole assigns a role to a user using GORM associations for security
func (r *userRepository) AssignRole(userID, roleID uint) error {
	// Input validation
	if userID == 0 || roleID == 0 {
		return fmt.Errorf("invalid user ID or role ID")
	}

	// Use transaction for data consistency
	return r.db.Transaction(func(tx *gorm.DB) error {
		// Verify user exists
		var user models.User
		if err := tx.First(&user, userID).Error; err != nil {
			return fmt.Errorf("user not found")
		}

		// Verify role exists
		var role models.Role
		if err := tx.First(&role, roleID).Error; err != nil {
			return fmt.Errorf("role not found")
		}

		// Use GORM association to safely add role
		return tx.Model(&user).Association("Roles").Append(&role)
	})
}

// RemoveRole removes a role from a user using GORM associations for security
func (r *userRepository) RemoveRole(userID, roleID uint) error {
	// Input validation
	if userID == 0 || roleID == 0 {
		return fmt.Errorf("invalid user ID or role ID")
	}

	// Use transaction for data consistency
	return r.db.Transaction(func(tx *gorm.DB) error {
		// Verify user exists
		var user models.User
		if err := tx.First(&user, userID).Error; err != nil {
			return fmt.Errorf("user not found")
		}

		// Verify role exists and user has it
		var role models.Role
		if err := tx.First(&role, roleID).Error; err != nil {
			return fmt.Errorf("role not found")
		}

		// Use GORM association to safely remove role
		return tx.Model(&user).Association("Roles").Delete(&role)
	})
}