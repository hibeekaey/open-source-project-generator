package controllers

import (
	"net/http"
	"strings"

	"{{.Name}}/internal/models"
	"{{.Name}}/internal/services"
	"{{.Name}}/pkg/utils"
	"github.com/gin-gonic/gin"
)

// AuthController handles authentication-related requests
type AuthController struct {
	authService services.AuthService
	userService services.UserService
}

// NewAuthController creates a new auth controller
func NewAuthController(authService services.AuthService, userService services.UserService) *AuthController {
	return &AuthController{
		authService: authService,
		userService: userService,
	}
}

// Login godoc
// @Summary User login
// @Description Authenticate user with email and password
// @Tags auth
// @Accept json
// @Produce json
// @Param request body models.LoginRequest true "Login credentials"
// @Success 200 {object} models.LoginResponse
// @Failure 400 {object} utils.ErrorResponse
// @Failure 401 {object} utils.ErrorResponse
// @Router /auth/login [post]
func (c *AuthController) Login(ctx *gin.Context) {
	var req models.LoginRequest
	if err := ctx.ShouldBindJSON(&req); err != nil {
		utils.ErrorResponse(ctx, http.StatusBadRequest, "Invalid request payload", err)
		return
	}

	if err := utils.ValidateStruct(&req); err != nil {
		utils.ValidationErrorResponse(ctx, err)
		return
	}

	response, err := c.authService.Login(&req)
	if err != nil {
		utils.UnauthorizedResponse(ctx, "Login failed")
		return
	}

	utils.SuccessResponse(ctx, http.StatusOK, "Login successful", response)
}

// Register godoc
// @Summary User registration
// @Description Register a new user account
// @Tags auth
// @Accept json
// @Produce json
// @Param request body models.UserCreateRequest true "User registration data"
// @Success 201 {object} models.UserResponse
// @Failure 400 {object} utils.ErrorResponse
// @Failure 409 {object} utils.ErrorResponse
// @Router /auth/register [post]
func (c *AuthController) Register(ctx *gin.Context) {
	var req models.UserCreateRequest
	if err := ctx.ShouldBindJSON(&req); err != nil {
		utils.ErrorResponse(ctx, http.StatusBadRequest, "Invalid request payload", err)
		return
	}

	if err := utils.ValidateStruct(&req); err != nil {
		utils.ValidationErrorResponse(ctx, err)
		return
	}

	user, err := c.userService.Create(&req)
	if err != nil {
		// Check if it's a duplicate user error
		if strings.Contains(err.Error(), "already exists") || strings.Contains(err.Error(), "duplicate") {
			utils.SecureErrorResponse(ctx, http.StatusConflict, "User registration failed", err, "duplicate_user_registration")
		} else {
			utils.InternalServerErrorResponse(ctx, err)
		}
		return
	}

	utils.SuccessResponse(ctx, http.StatusCreated, "User registered successfully", user.ToResponse())
}

// RefreshToken godoc
// @Summary Refresh access token
// @Description Refresh access token using refresh token
// @Tags auth
// @Accept json
// @Produce json
// @Param request body models.RefreshTokenRequest true "Refresh token"
// @Success 200 {object} models.LoginResponse
// @Failure 400 {object} utils.ErrorResponse
// @Failure 401 {object} utils.ErrorResponse
// @Router /auth/refresh [post]
func (c *AuthController) RefreshToken(ctx *gin.Context) {
	var req models.RefreshTokenRequest
	if err := ctx.ShouldBindJSON(&req); err != nil {
		utils.ErrorResponse(ctx, http.StatusBadRequest, "Invalid request payload", err)
		return
	}

	if err := utils.ValidateStruct(&req); err != nil {
		utils.ValidationErrorResponse(ctx, err)
		return
	}

	response, err := c.authService.RefreshToken(&req)
	if err != nil {
		utils.UnauthorizedResponse(ctx, "Token refresh failed")
		return
	}

	utils.SuccessResponse(ctx, http.StatusOK, "Token refreshed successfully", response)
}

// Logout godoc
// @Summary User logout
// @Description Logout user and invalidate tokens
// @Tags auth
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} utils.SuccessResponse
// @Failure 401 {object} utils.ErrorResponse
// @Router /auth/logout [post]
func (c *AuthController) Logout(ctx *gin.Context) {
	userID, exists := ctx.Get("user_id")
	if !exists {
		utils.UnauthorizedResponse(ctx, "User not authenticated")
		return
	}

	// Get token from header
	token := ctx.GetHeader("Authorization")
	if token != "" && len(token) > 7 {
		token = token[7:] // Remove "Bearer " prefix
	}

	err := c.authService.Logout(userID.(uint), token)
	if err != nil {
		utils.InternalServerErrorResponse(ctx, err)
		return
	}

	utils.SuccessResponse(ctx, http.StatusOK, "Logout successful", nil)
}

// ChangePassword godoc
// @Summary Change user password
// @Description Change the current user's password
// @Tags auth
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body models.ChangePasswordRequest true "Password change data"
// @Success 200 {object} utils.SuccessResponse
// @Failure 400 {object} utils.ErrorResponse
// @Failure 401 {object} utils.ErrorResponse
// @Router /auth/change-password [post]
func (c *AuthController) ChangePassword(ctx *gin.Context) {
	userID, exists := ctx.Get("user_id")
	if !exists {
		utils.ErrorResponse(ctx, http.StatusUnauthorized, "User not authenticated", nil)
		return
	}

	var req models.ChangePasswordRequest
	if err := ctx.ShouldBindJSON(&req); err != nil {
		utils.ErrorResponse(ctx, http.StatusBadRequest, "Invalid request payload", err)
		return
	}

	if err := utils.ValidateStruct(&req); err != nil {
		utils.ValidationErrorResponse(ctx, err)
		return
	}

	err := c.authService.ChangePassword(userID.(uint), &req)
	if err != nil {
		utils.ErrorResponse(ctx, http.StatusBadRequest, err.Error(), nil)
		return
	}

	utils.SuccessResponse(ctx, http.StatusOK, "Password changed successfully", nil)
}

// ResetPassword godoc
// @Summary Request password reset
// @Description Request a password reset email
// @Tags auth
// @Accept json
// @Produce json
// @Param request body models.ResetPasswordRequest true "Password reset request"
// @Success 200 {object} utils.SuccessResponse
// @Failure 400 {object} utils.ErrorResponse
// @Router /auth/reset-password [post]
func (c *AuthController) ResetPassword(ctx *gin.Context) {
	var req models.ResetPasswordRequest
	if err := ctx.ShouldBindJSON(&req); err != nil {
		utils.ErrorResponse(ctx, http.StatusBadRequest, "Invalid request payload", err)
		return
	}

	if err := utils.ValidateStruct(&req); err != nil {
		utils.ValidationErrorResponse(ctx, err)
		return
	}

	err := c.authService.ResetPassword(&req)
	if err != nil {
		utils.ErrorResponse(ctx, http.StatusInternalServerError, "Failed to process reset request", err)
		return
	}

	utils.SuccessResponse(ctx, http.StatusOK, "Password reset email sent", nil)
}

// ConfirmPasswordReset godoc
// @Summary Confirm password reset
// @Description Confirm password reset with token
// @Tags auth
// @Accept json
// @Produce json
// @Param request body models.ResetPasswordConfirmRequest true "Password reset confirmation"
// @Success 200 {object} utils.SuccessResponse
// @Failure 400 {object} utils.ErrorResponse
// @Router /auth/reset-password/confirm [post]
func (c *AuthController) ConfirmPasswordReset(ctx *gin.Context) {
	var req models.ResetPasswordConfirmRequest
	if err := ctx.ShouldBindJSON(&req); err != nil {
		utils.ErrorResponse(ctx, http.StatusBadRequest, "Invalid request payload", err)
		return
	}

	if err := utils.ValidateStruct(&req); err != nil {
		utils.ValidationErrorResponse(ctx, err)
		return
	}

	err := c.authService.ConfirmPasswordReset(&req)
	if err != nil {
		utils.ErrorResponse(ctx, http.StatusBadRequest, err.Error(), nil)
		return
	}

	utils.SuccessResponse(ctx, http.StatusOK, "Password reset successful", nil)
}

// Me godoc
// @Summary Get current user
// @Description Get current authenticated user information
// @Tags auth
// @Produce json
// @Security BearerAuth
// @Success 200 {object} models.UserResponse
// @Failure 401 {object} utils.ErrorResponse
// @Router /auth/me [get]
func (c *AuthController) Me(ctx *gin.Context) {
	user, exists := ctx.Get("user")
	if !exists {
		utils.ErrorResponse(ctx, http.StatusUnauthorized, "User not authenticated", nil)
		return
	}

	userModel, ok := user.(*models.User)
	if !ok {
		utils.ErrorResponse(ctx, http.StatusInternalServerError, "Invalid user type", nil)
		return
	}

	utils.SuccessResponse(ctx, http.StatusOK, "User information retrieved", userModel.ToResponse())
}