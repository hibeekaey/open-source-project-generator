package models

import (
	"fmt"
	"time"

	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

// User represents a user in the system with enhanced security fields
type User struct {
	ID                 uint           `json:"id" gorm:"primaryKey"`
	Email              string         `json:"email" gorm:"uniqueIndex;not null" validate:"required,email,safe_string"`
	Username           string         `json:"username" gorm:"uniqueIndex;not null" validate:"required,min=3,max=50,safe_string,no_sql_injection"`
	Password           string         `json:"-" gorm:"not null" validate:"required,secure_password"`
	FirstName          string         `json:"first_name" validate:"required,min=1,max=50,safe_string"`
	LastName           string         `json:"last_name" validate:"required,min=1,max=50,safe_string"`
	IsActive           bool           `json:"is_active" gorm:"default:true"`
	IsAdmin            bool           `json:"is_admin" gorm:"default:false"`
	
	// Security-related fields
	LockedAt           *time.Time     `json:"locked_at,omitempty" gorm:"index"`
	LastPasswordChange *time.Time     `json:"last_password_change,omitempty"`
	AdminExpiresAt     *time.Time     `json:"admin_expires_at,omitempty"`
	FailedLoginAttempts int           `json:"failed_login_attempts" gorm:"default:0"`
	LastLoginAt        *time.Time     `json:"last_login_at,omitempty"`
	LastLoginIP        string         `json:"last_login_ip,omitempty"`
	
	Roles     []Role         `json:"roles" gorm:"many2many:user_roles;"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	DeletedAt gorm.DeletedAt `json:"-" gorm:"index"`
}

// UserCreateRequest represents the request payload for creating a user
type UserCreateRequest struct {
	Email     string `json:"email" validate:"required,email,safe_string"`
	Username  string `json:"username" validate:"required,min=3,max=50,safe_string,no_sql_injection"`
	Password  string `json:"password" validate:"required,secure_password"`
	FirstName string `json:"first_name" validate:"required,min=1,max=50,safe_string"`
	LastName  string `json:"last_name" validate:"required,min=1,max=50,safe_string"`
}

// UserUpdateRequest represents the request payload for updating a user
type UserUpdateRequest struct {
	Email     *string `json:"email,omitempty" validate:"omitempty,email,safe_string"`
	Username  *string `json:"username,omitempty" validate:"omitempty,min=3,max=50,safe_string,no_sql_injection"`
	FirstName *string `json:"first_name,omitempty" validate:"omitempty,min=1,max=50,safe_string"`
	LastName  *string `json:"last_name,omitempty" validate:"omitempty,min=1,max=50,safe_string"`
	IsActive  *bool   `json:"is_active,omitempty"`
}

// UserResponse represents the response payload for user data
type UserResponse struct {
	ID        uint      `json:"id"`
	Email     string    `json:"email"`
	Username  string    `json:"username"`
	FirstName string    `json:"first_name"`
	LastName  string    `json:"last_name"`
	IsActive  bool      `json:"is_active"`
	IsAdmin   bool      `json:"is_admin"`
	Roles     []Role    `json:"roles"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// BeforeCreate is a GORM hook that runs before creating a user
func (u *User) BeforeCreate(tx *gorm.DB) error {
	return u.HashPassword()
}

// HashPassword hashes the user's password with secure cost factor
func (u *User) HashPassword() error {
	// Use a higher cost factor for better security (12 instead of default 10)
	const secureHashCost = 12
	
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(u.Password), secureHashCost)
	if err != nil {
		return fmt.Errorf("failed to hash password: %w", err)
	}
	u.Password = string(hashedPassword)
	
	// Update password change timestamp
	u.SetPasswordChanged()
	
	return nil
}

// CheckPassword checks if the provided password matches the user's password
func (u *User) CheckPassword(password string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
	return err == nil
}

// ToResponse converts a User to UserResponse
func (u *User) ToResponse() UserResponse {
	return UserResponse{
		ID:        u.ID,
		Email:     u.Email,
		Username:  u.Username,
		FirstName: u.FirstName,
		LastName:  u.LastName,
		IsActive:  u.IsActive,
		IsAdmin:   u.IsAdmin,
		Roles:     u.Roles,
		CreatedAt: u.CreatedAt,
		UpdatedAt: u.UpdatedAt,
	}
}
/
/ Security helper methods

// IsLocked checks if the user account is currently locked
func (u *User) IsLocked() bool {
	return u.LockedAt != nil && time.Now().Before(*u.LockedAt)
}

// LockAccount locks the user account for the specified duration
func (u *User) LockAccount(duration time.Duration) {
	lockUntil := time.Now().Add(duration)
	u.LockedAt = &lockUntil
}

// UnlockAccount unlocks the user account
func (u *User) UnlockAccount() {
	u.LockedAt = nil
	u.FailedLoginAttempts = 0
}

// IncrementFailedLogin increments the failed login attempts counter
func (u *User) IncrementFailedLogin() {
	u.FailedLoginAttempts++
}

// ResetFailedLogin resets the failed login attempts counter
func (u *User) ResetFailedLogin() {
	u.FailedLoginAttempts = 0
}

// UpdateLastLogin updates the last login timestamp and IP
func (u *User) UpdateLastLogin(ip string) {
	now := time.Now()
	u.LastLoginAt = &now
	u.LastLoginIP = ip
}

// SetPasswordChanged updates the last password change timestamp
func (u *User) SetPasswordChanged() {
	now := time.Now()
	u.LastPasswordChange = &now
}

// IsAdminExpired checks if admin privileges have expired
func (u *User) IsAdminExpired() bool {
	return u.IsAdmin && u.AdminExpiresAt != nil && time.Now().After(*u.AdminExpiresAt)
}

// SetAdminExpiration sets admin privilege expiration
func (u *User) SetAdminExpiration(expiration time.Time) {
	u.AdminExpiresAt = &expiration
}

// HasPermission checks if user has a specific permission
func (u *User) HasPermission(resource, action string) bool {
	// Admin users have all permissions (unless expired)
	if u.IsAdmin && !u.IsAdminExpired() {
		return true
	}

	// Check role-based permissions
	for _, role := range u.Roles {
		if !role.IsActive || (role.ExpiresAt != nil && time.Now().After(*role.ExpiresAt)) {
			continue
		}

		for _, permission := range role.Permissions {
			if !permission.IsActive || (permission.ExpiresAt != nil && time.Now().After(*permission.ExpiresAt)) {
				continue
			}

			if permission.Resource == resource && permission.Action == action {
				return true
			}
		}
	}

	return false
}