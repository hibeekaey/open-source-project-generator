package utils

import (
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/go-playground/validator/v10"
)

func TestValidateSecurePassword(t *testing.T) {
	tests := []struct {
		name     string
		password string
		valid    bool
	}{
		{
			name:     "Valid secure password",
			password: "MySecure123!",
			valid:    true,
		},
		{
			name:     "Too short",
			password: "Abc1!",
			valid:    false,
		},
		{
			name:     "No uppercase",
			password: "mysecure123!",
			valid:    false,
		},
		{
			name:     "No lowercase",
			password: "MYSECURE123!",
			valid:    false,
		},
		{
			name:     "No digit",
			password: "MySecurePass!",
			valid:    false,
		},
		{
			name:     "No special character",
			password: "MySecure123",
			valid:    false,
		},
		{
			name:     "Complex valid password",
			password: "Th1s!sAV3ryS3cur3P@ssw0rd",
			valid:    true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a mock field level for testing
			fl := &mockFieldLevel{value: tt.password}
			result := validateSecurePassword(fl)
			assert.Equal(t, tt.valid, result, "Password validation failed for: %s", tt.password)
		})
	}
}

func TestValidateSafeString(t *testing.T) {
	tests := []struct {
		name  string
		input string
		valid bool
	}{
		{
			name:  "Safe string",
			input: "This is a safe string",
			valid: true,
		},
		{
			name:  "Script tag",
			input: "<script>alert('xss')</script>",
			valid: false,
		},
		{
			name:  "JavaScript protocol",
			input: "javascript:alert('xss')",
			valid: false,
		},
		{
			name:  "VBScript protocol",
			input: "vbscript:msgbox('xss')",
			valid: false,
		},
		{
			name:  "Onload event",
			input: "onload=alert('xss')",
			valid: false,
		},
		{
			name:  "Eval function",
			input: "eval(maliciousCode)",
			valid: false,
		},
		{
			name:  "Document cookie",
			input: "document.cookie",
			valid: false,
		},
		{
			name:  "Normal text with numbers",
			input: "User123 with normal text",
			valid: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			fl := &mockFieldLevel{value: tt.input}
			result := validateSafeString(fl)
			assert.Equal(t, tt.valid, result, "Safe string validation failed for: %s", tt.input)
		})
	}
}

func TestValidateNoSQLInjection(t *testing.T) {
	tests := []struct {
		name  string
		input string
		valid bool
	}{
		{
			name:  "Safe string",
			input: "normal user input",
			valid: true,
		},
		{
			name:  "Single quote",
			input: "user's input",
			valid: false,
		},
		{
			name:  "Double quote",
			input: "user \"quoted\" input",
			valid: false,
		},
		{
			name:  "Semicolon",
			input: "user; DROP TABLE users;",
			valid: false,
		},
		{
			name:  "SQL comment",
			input: "user -- comment",
			valid: false,
		},
		{
			name:  "Union select",
			input: "user UNION SELECT * FROM users",
			valid: false,
		},
		{
			name:  "Insert statement",
			input: "INSERT INTO users VALUES",
			valid: false,
		},
		{
			name:  "Update statement",
			input: "UPDATE users SET password",
			valid: false,
		},
		{
			name:  "Delete statement",
			input: "DELETE FROM users",
			valid: false,
		},
		{
			name:  "Drop statement",
			input: "DROP TABLE users",
			valid: false,
		},
		{
			name:  "Exec function",
			input: "EXEC xp_cmdshell",
			valid: false,
		},
		{
			name:  "Normal alphanumeric",
			input: "user123",
			valid: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			fl := &mockFieldLevel{value: tt.input}
			result := validateNoSQLInjection(fl)
			assert.Equal(t, tt.valid, result, "SQL injection validation failed for: %s", tt.input)
		})
	}
}

func TestSanitizeInput(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "Normal string",
			input:    "Hello World",
			expected: "Hello World",
		},
		{
			name:     "String with null bytes",
			input:    "Hello\x00World",
			expected: "HelloWorld",
		},
		{
			name:     "String with leading/trailing whitespace",
			input:    "  Hello World  ",
			expected: "Hello World",
		},
		{
			name:     "String with control characters",
			input:    "Hello\x01\x02World",
			expected: "HelloWorld",
		},
		{
			name:     "String with allowed control characters",
			input:    "Hello\tWorld\nTest\r",
			expected: "Hello\tWorld\nTest\r",
		},
		{
			name:     "Empty string",
			input:    "",
			expected: "",
		},
		{
			name:     "Only whitespace",
			input:    "   \t\n\r   ",
			expected: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := SanitizeInput(tt.input)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestValidateID(t *testing.T) {
	tests := []struct {
		name  string
		id    uint
		valid bool
	}{
		{
			name:  "Valid ID",
			id:    1,
			valid: true,
		},
		{
			name:  "Valid large ID",
			id:    999999,
			valid: true,
		},
		{
			name:  "Invalid zero ID",
			id:    0,
			valid: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := ValidateID(tt.id)
			if tt.valid {
				assert.NoError(t, err)
			} else {
				assert.Error(t, err)
				assert.Contains(t, err.Error(), "invalid ID")
			}
		})
	}
}

func TestValidatePaginationParams(t *testing.T) {
	tests := []struct {
		name   string
		offset int
		limit  int
		valid  bool
	}{
		{
			name:   "Valid pagination",
			offset: 0,
			limit:  10,
			valid:  true,
		},
		{
			name:   "Valid pagination with offset",
			offset: 20,
			limit:  50,
			valid:  true,
		},
		{
			name:   "Negative offset",
			offset: -1,
			limit:  10,
			valid:  false,
		},
		{
			name:   "Zero limit",
			offset: 0,
			limit:  0,
			valid:  false,
		},
		{
			name:   "Negative limit",
			offset: 0,
			limit:  -1,
			valid:  false,
		},
		{
			name:   "Limit too high",
			offset: 0,
			limit:  1001,
			valid:  false,
		},
		{
			name:   "Maximum valid limit",
			offset: 0,
			limit:  1000,
			valid:  true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := ValidatePaginationParams(tt.offset, tt.limit)
			if tt.valid {
				assert.NoError(t, err)
			} else {
				assert.Error(t, err)
			}
		})
	}
}

// Mock implementation for testing
type mockFieldLevel struct {
	value string
}

func (m *mockFieldLevel) Top() reflect.Value {
	return reflect.Value{}
}

func (m *mockFieldLevel) Parent() reflect.Value {
	return reflect.Value{}
}

func (m *mockFieldLevel) Field() reflect.Value {
	return reflect.ValueOf(m.value)
}

func (m *mockFieldLevel) FieldName() string {
	return "test_field"
}

func (m *mockFieldLevel) StructFieldName() string {
	return "TestField"
}

func (m *mockFieldLevel) Param() string {
	return ""
}

func (m *mockFieldLevel) GetTag() string {
	return ""
}

func (m *mockFieldLevel) ExtractType(field reflect.Value) (reflect.Value, reflect.Kind, bool) {
	return reflect.Value{}, reflect.String, false
}

func (m *mockFieldLevel) GetStructFieldOK() (reflect.Value, reflect.Kind, bool) {
	return reflect.Value{}, reflect.String, false
}

func (m *mockFieldLevel) GetStructFieldOKAdvanced(val reflect.Value, namespace string) (reflect.Value, reflect.Kind, bool) {
	return reflect.Value{}, reflect.String, false
}

func (m *mockFieldLevel) GetStructFieldOK2() (reflect.Value, reflect.Kind, string, bool) {
	return reflect.Value{}, reflect.String, "", false
}

func (m *mockFieldLevel) GetStructFieldOKAdvanced2(val reflect.Value, namespace string) (reflect.Value, reflect.Kind, string, bool) {
	return reflect.Value{}, reflect.String, "", false
}