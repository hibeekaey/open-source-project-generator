name: Release

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major
      prerelease:
        description: 'Create a prerelease'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '{{.Versions.Node}}'
  GO_VERSION: '{{.Versions.Go}}'

jobs:
  determine-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      changelog: ${{ steps.changelog.outputs.changelog }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Install semantic-release
      run: |
        npm install -g semantic-release @semantic-release/changelog @semantic-release/git @semantic-release/github

    - name: Determine next version
      id: version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # Manual release
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          CURRENT_VERSION=${CURRENT_VERSION#v}
          
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}
          
          case $RELEASE_TYPE in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          if [ "${{ github.event.inputs.prerelease }}" = "true" ]; then
            NEW_VERSION="$NEW_VERSION-rc.$(date +%Y%m%d%H%M%S)"
          fi
        else
          # Automatic release using semantic-release
          NEW_VERSION=$(npx semantic-release --dry-run | grep -oP 'The next release version is \K[0-9]+\.[0-9]+\.[0-9]+' || echo "")
          if [ -z "$NEW_VERSION" ]; then
            echo "No release needed"
            exit 0
          fi
        fi
        
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "Next version: $NEW_VERSION"

    - name: Generate changelog
      id: changelog
      run: |
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        if [ -z "$LAST_TAG" ]; then
          CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges)
        else
          CHANGELOG=$(git log $LAST_TAG..HEAD --pretty=format:"- %s (%h)" --no-merges)
        fi
        
        # Save changelog to file for multiline output
        echo "$CHANGELOG" > changelog.txt
        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        cat changelog.txt >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

  run-tests:
    runs-on: ubuntu-latest
    needs: determine-version
    if: needs.determine-version.outputs.version != ''
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Run CI tests
      uses: ./.github/workflows/ci-frontend.yml

    - name: Run backend tests
      uses: ./.github/workflows/ci-backend.yml

    {{if or .Components.Mobile.Android .Components.Mobile.iOS}}
    - name: Run mobile tests
      uses: ./.github/workflows/ci-mobile.yml
    {{end}}

  build-artifacts:
    runs-on: ubuntu-latest
    needs: [determine-version, run-tests]
    if: needs.determine-version.outputs.version != ''
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    # Build frontend applications
    {{if .Components.Frontend.MainApp}}
    - name: Build App
      run: |
        cd App
        npm ci
        npm run build
        tar -czf ../{{.Name | lower}}-app-${{ needs.determine-version.outputs.version }}.tar.gz build/
    {{end}}

    {{if .Components.Frontend.Home}}
    - name: Build Home
      run: |
        cd Home
        npm ci
        npm run build
        tar -czf ../{{.Name | lower}}-home-${{ needs.determine-version.outputs.version }}.tar.gz build/
    {{end}}

    {{if .Components.Frontend.Admin}}
    - name: Build Admin
      run: |
        cd Admin
        npm ci
        npm run build
        tar -czf ../{{.Name | lower}}-admin-${{ needs.determine-version.outputs.version }}.tar.gz build/
    {{end}}

    # Build backend
    - name: Build backend
      run: |
        CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o {{.Name | lower}}-api-linux-amd64 ./cmd/server
        CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags="-s -w" -o {{.Name | lower}}-api-darwin-amd64 ./cmd/server
        CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags="-s -w" -o {{.Name | lower}}-api-windows-amd64.exe ./cmd/server

    # Upload artifacts
    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: release-artifacts-${{ needs.determine-version.outputs.version }}
        path: |
          {{.Name | lower}}-*-${{ needs.determine-version.outputs.version }}.tar.gz
          {{.Name | lower}}-api-*

  create-release:
    runs-on: ubuntu-latest
    needs: [determine-version, run-tests, build-artifacts]
    if: needs.determine-version.outputs.version != ''
    permissions:
      contents: write
      packages: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: release-artifacts-${{ needs.determine-version.outputs.version }}

    - name: Create Git tag
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a ${{ needs.determine-version.outputs.tag }} -m "Release ${{ needs.determine-version.outputs.tag }}"
        git push origin ${{ needs.determine-version.outputs.tag }}

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ needs.determine-version.outputs.tag }}
        name: Release ${{ needs.determine-version.outputs.tag }}
        body: |
          ## What's Changed
          
          ${{ needs.determine-version.outputs.changelog }}
          
          ## Installation
          
          ### Backend API
          ```bash
          # Linux
          wget https://github.com/${{ github.repository }}/releases/download/${{ needs.determine-version.outputs.tag }}/{{.Name | lower}}-api-linux-amd64
          chmod +x {{.Name | lower}}-api-linux-amd64
          
          # macOS
          wget https://github.com/${{ github.repository }}/releases/download/${{ needs.determine-version.outputs.tag }}/{{.Name | lower}}-api-darwin-amd64
          chmod +x {{.Name | lower}}-api-darwin-amd64
          
          # Windows
          wget https://github.com/${{ github.repository }}/releases/download/${{ needs.determine-version.outputs.tag }}/{{.Name | lower}}-api-windows-amd64.exe
          ```
          
          ### Frontend Applications
          {{if .Components.Frontend.MainApp}}
          - **App**: Download `{{.Name | lower}}-app-${{ needs.determine-version.outputs.version }}.tar.gz`
          {{end}}
          {{if .Components.Frontend.Home}}
          - **Home**: Download `{{.Name | lower}}-home-${{ needs.determine-version.outputs.version }}.tar.gz`
          {{end}}
          {{if .Components.Frontend.Admin}}
          - **Admin**: Download `{{.Name | lower}}-admin-${{ needs.determine-version.outputs.version }}.tar.gz`
          {{end}}
          
          ### Docker Images
          ```bash
          docker pull ghcr.io/${{ github.repository }}-api:${{ needs.determine-version.outputs.tag }}
          {{if .Components.Frontend.MainApp}}docker pull ghcr.io/${{ github.repository }}-app:${{ needs.determine-version.outputs.tag }}{{end}}
          {{if .Components.Frontend.Home}}docker pull ghcr.io/${{ github.repository }}-home:${{ needs.determine-version.outputs.tag }}{{end}}
          {{if .Components.Frontend.Admin}}docker pull ghcr.io/${{ github.repository }}-admin:${{ needs.determine-version.outputs.tag }}{{end}}
          ```
          
          ## Deployment
          
          Use the provided Kubernetes manifests in the `Deploy/` directory or Docker Compose files for deployment.
          
          **Full Changelog**: https://github.com/${{ github.repository }}/compare/v${{ needs.determine-version.outputs.version }}...HEAD
        files: |
          {{.Name | lower}}-*-${{ needs.determine-version.outputs.version }}.tar.gz
          {{.Name | lower}}-api-*
        prerelease: ${{ github.event.inputs.prerelease == 'true' }}
        make_latest: ${{ github.event.inputs.prerelease != 'true' }}

    - name: Trigger production deployment
      if: github.event.inputs.prerelease != 'true'
      uses: peter-evans/repository-dispatch@v2
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        event-type: production-deploy
        client-payload: '{"version": "${{ needs.determine-version.outputs.tag }}"}'

  notify-release:
    runs-on: ubuntu-latest
    needs: [determine-version, create-release]
    if: always() && needs.determine-version.outputs.version != ''
    
    steps:
    - name: Notify Slack
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ needs.create-release.result }}
        channel: '#releases'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        fields: repo,message,commit,author,action,eventName,ref,workflow
        custom_payload: |
          {
            "text": "${{ needs.create-release.result == 'success' && 'üéâ New release published!' || '‚ùå Release failed!' }}",
            "attachments": [{
              "color": "${{ needs.create-release.result == 'success' && 'good' || 'danger' }}",
              "fields": [{
                "title": "Version",
                "value": "${{ needs.determine-version.outputs.tag }}",
                "short": true
              }, {
                "title": "Repository",
                "value": "${{ github.repository }}",
                "short": true
              }, {
                "title": "Release Notes",
                "value": "https://github.com/${{ github.repository }}/releases/tag/${{ needs.determine-version.outputs.tag }}",
                "short": false
              }]
            }]
          }

    - name: Update documentation
      if: needs.create-release.result == 'success'
      run: |
        # Trigger documentation update workflow
        curl -X POST \
          -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          https://api.github.com/repos/${{ github.repository }}/dispatches \
          -d '{"event_type":"update-docs","client_payload":{"version":"${{ needs.determine-version.outputs.tag }}"}}'