#!/bin/bash

# {{.Name}} - Deployment Script
# This script deploys the application to various environments

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
PROJECT_NAME="{{.Name}}"
ORGANIZATION="{{.Organization}}"
DEFAULT_ENVIRONMENT="development"

# Directories
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
DEPLOY_DIR="$PROJECT_ROOT/Deploy"

# Deployment configuration
ENVIRONMENT="${1:-$DEFAULT_ENVIRONMENT}"
VERSION="${VERSION:-$(git describe --tags --always --dirty 2>/dev/null || echo "dev")}"
BUILD_TIME="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
GIT_COMMIT="$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")"

# Deployment options
DRY_RUN="${DRY_RUN:-false}"
SKIP_TESTS="${SKIP_TESTS:-false}"
SKIP_BUILD="${SKIP_BUILD:-false}"
FORCE_DEPLOY="${FORCE_DEPLOY:-false}"
ROLLBACK_ON_FAILURE="${ROLLBACK_ON_FAILURE:-true}"

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_step() {
    echo -e "${CYAN}[STEP]${NC} $1"
}

# Error handling
handle_error() {
    log_error "Deployment failed at line $1"
    
    if [[ "$ROLLBACK_ON_FAILURE" == "true" && "$ENVIRONMENT" == "production" ]]; then
        log_warning "Initiating rollback..."
        rollback_deployment
    fi
    
    cleanup_on_error
    exit 1
}

trap 'handle_error $LINENO' ERR

# Cleanup function
cleanup_on_error() {
    log_warning "Cleaning up after deployment failure..."
    
    # Kill any background processes
    jobs -p | xargs -r kill 2>/dev/null || true
    
    # Clean up temporary files
    rm -f /tmp/{{.Name}}-deploy-* 2>/dev/null || true
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Load environment configuration
load_environment_config() {
    log_step "Loading environment configuration for $ENVIRONMENT..."
    
    local config_file="$DEPLOY_DIR/environments/$ENVIRONMENT.env"
    
    if [[ -f "$config_file" ]]; then
        log_info "Loading configuration from $config_file"
        source "$config_file"
    else
        log_warning "Environment configuration file not found: $config_file"
        log_info "Using default configuration"
    fi
    
    # Set default values if not provided
    DEPLOY_METHOD="${DEPLOY_METHOD:-docker}"
    REGISTRY_URL="${REGISTRY_URL:-{{.Organization}}}"
    NAMESPACE="${NAMESPACE:-{{.Name}}-$ENVIRONMENT}"
    REPLICAS="${REPLICAS:-1}"
    
    case "$ENVIRONMENT" in
        development|dev)
            REPLICAS="${REPLICAS:-1}"
            HEALTH_CHECK_TIMEOUT="${HEALTH_CHECK_TIMEOUT:-60}"
            ;;
        staging|stage)
            REPLICAS="${REPLICAS:-2}"
            HEALTH_CHECK_TIMEOUT="${HEALTH_CHECK_TIMEOUT:-120}"
            ;;
        production|prod)
            REPLICAS="${REPLICAS:-3}"
            HEALTH_CHECK_TIMEOUT="${HEALTH_CHECK_TIMEOUT:-300}"
            ;;
    esac
    
    log_success "Environment configuration loaded"
    log_info "Deploy method: $DEPLOY_METHOD"
    log_info "Registry: $REGISTRY_URL"
    log_info "Namespace: $NAMESPACE"
    log_info "Replicas: $REPLICAS"
}

# Validate deployment prerequisites
validate_prerequisites() {
    log_step "Validating deployment prerequisites..."
    
    # Check required tools based on deployment method
    case "$DEPLOY_METHOD" in
        docker)
            if ! command_exists docker; then
                log_error "Docker is required for Docker deployment"
                exit 1
            fi
            ;;
        kubernetes|k8s)
            if ! command_exists kubectl; then
                log_error "kubectl is required for Kubernetes deployment"
                exit 1
            fi
            
            if ! command_exists helm; then
                log_error "Helm is required for Kubernetes deployment"
                exit 1
            fi
            ;;
        terraform)
            if ! command_exists terraform; then
                log_error "Terraform is required for Terraform deployment"
                exit 1
            fi
            ;;
    esac
    
    # Check Git status for production deployments
    if [[ "$ENVIRONMENT" == "production" ]]; then
        if [[ -d .git ]]; then
            local git_status=$(git status --porcelain)
            if [[ -n "$git_status" && "$FORCE_DEPLOY" != "true" ]]; then
                log_error "Working directory is not clean. Commit changes or use --force"
                log_info "Uncommitted changes:"
                git status --short
                exit 1
            fi
            
            local current_branch=$(git rev-parse --abbrev-ref HEAD)
            if [[ "$current_branch" != "main" && "$current_branch" != "master" && "$FORCE_DEPLOY" != "true" ]]; then
                log_warning "Not on main/master branch (current: $current_branch)"
                log_warning "Use --force to deploy from this branch"
                exit 1
            fi
        fi
    fi
    
    # Check environment-specific prerequisites
    case "$ENVIRONMENT" in
        production)
            if [[ "$DRY_RUN" != "true" ]]; then
                log_warning "Deploying to PRODUCTION environment"
                read -p "Are you sure you want to continue? [y/N] " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    log_info "Deployment canceled"
                    exit 0
                fi
            fi
            ;;
    esac
    
    log_success "Prerequisites validation passed"
}

# Run pre-deployment tests
run_pre_deployment_tests() {
    if [[ "$SKIP_TESTS" == "true" ]]; then
        log_warning "Skipping tests (SKIP_TESTS=true)"
        return 0
    fi
    
    log_step "Running pre-deployment tests..."
    
    cd "$PROJECT_ROOT"
    
    # Run test script if available
    if [[ -f "$SCRIPT_DIR/test.sh" ]]; then
        log_info "Running test suite..."
        bash "$SCRIPT_DIR/test.sh" --mode=all --no-coverage
    else
        log_warning "Test script not found, running basic tests..."
        
        # Run make test if Makefile exists
        if [[ -f Makefile ]]; then
            make test
        else
            log_warning "No test configuration found"
        fi
    fi
    
    log_success "Pre-deployment tests passed"
}

# Build application
build_application() {
    if [[ "$SKIP_BUILD" == "true" ]]; then
        log_warning "Skipping build (SKIP_BUILD=true)"
        return 0
    fi
    
    log_step "Building application..."
    
    cd "$PROJECT_ROOT"
    
    # Set build environment variables
    export BUILD_MODE=production
    export VERSION="$VERSION"
    export BUILD_TIME="$BUILD_TIME"
    export GIT_COMMIT="$GIT_COMMIT"
    
    # Build using build script if available
    if [[ -f "$SCRIPT_DIR/build.sh" ]]; then
        log_info "Running build script..."
        bash "$SCRIPT_DIR/build.sh" --mode=production --docker
    else
        log_warning "Build script not found, running basic build..."
        
        # Run make build if Makefile exists
        if [[ -f Makefile ]]; then
            make build
            make docker-build
        else
            log_error "No build configuration found"
            exit 1
        fi
    fi
    
    log_success "Application build completed"
}

# Deploy using Docker
deploy_docker() {
    log_step "Deploying with Docker..."
    
    cd "$PROJECT_ROOT"
    
    # Tag images with version
{{if .Components.Frontend.MainApp}}    local frontend_images=("app"{{if .Components.Frontend.Home}} "home"{{end}}{{if .Components.Frontend.Admin}} "admin"{{end}})
    for image in "${frontend_images[@]}"; do
        if docker images | grep -q "$REGISTRY_URL/{{.Name}}-$image"; then
            log_info "Tagging frontend image: $image"
            docker tag "$REGISTRY_URL/{{.Name}}-$image:latest" "$REGISTRY_URL/{{.Name}}-$image:$VERSION"
            
            if [[ "$DRY_RUN" != "true" ]]; then
                docker push "$REGISTRY_URL/{{.Name}}-$image:$VERSION"
                docker push "$REGISTRY_URL/{{.Name}}-$image:latest"
            fi
        fi
    done{{end}}
    
{{if .Components.Backend.API}}    # Backend image
    if docker images | grep -q "$REGISTRY_URL/{{.Name}}-backend"; then
        log_info "Tagging backend image"
        docker tag "$REGISTRY_URL/{{.Name}}-backend:latest" "$REGISTRY_URL/{{.Name}}-backend:$VERSION"
        
        if [[ "$DRY_RUN" != "true" ]]; then
            docker push "$REGISTRY_URL/{{.Name}}-backend:$VERSION"
            docker push "$REGISTRY_URL/{{.Name}}-backend:latest"
        fi
    fi{{end}}
    
    # Deploy with docker-compose
    local compose_file="docker-compose.$ENVIRONMENT.yml"
    
    if [[ -f "$compose_file" ]]; then
        log_info "Deploying with $compose_file"
        
        if [[ "$DRY_RUN" == "true" ]]; then
            log_info "DRY RUN: Would execute: docker-compose -f $compose_file up -d"
        else
            # Set environment variables for compose
            export VERSION="$VERSION"
            export ENVIRONMENT="$ENVIRONMENT"
            export REPLICAS="$REPLICAS"
            
            docker-compose -f "$compose_file" pull
            docker-compose -f "$compose_file" up -d
            
            # Wait for services to be healthy
            wait_for_health_check
        fi
    else
        log_error "Docker compose file not found: $compose_file"
        exit 1
    fi
    
    log_success "Docker deployment completed"
}

{{if .Components.Infrastructure.Kubernetes}}# Deploy using Kubernetes
deploy_kubernetes() {
    log_step "Deploying with Kubernetes..."
    
    cd "$PROJECT_ROOT"
    
    # Check cluster connection
    if ! kubectl cluster-info >/dev/null 2>&1; then
        log_error "Cannot connect to Kubernetes cluster"
        exit 1
    fi
    
    log_info "Connected to cluster: $(kubectl config current-context)"
    
    # Create namespace if it doesn't exist
    if [[ "$DRY_RUN" != "true" ]]; then
        kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
    fi
    
    # Deploy using Helm if chart exists
    if [[ -d "$DEPLOY_DIR/Kubernetes/helm" ]]; then
        log_info "Deploying with Helm..."
        
        local helm_args=(
            "upgrade" "--install" "$PROJECT_NAME"
            "$DEPLOY_DIR/Kubernetes/helm/"
            "--namespace" "$NAMESPACE"
            "--set" "image.tag=$VERSION"
            "--set" "environment=$ENVIRONMENT"
            "--set" "replicaCount=$REPLICAS"
        )
        
        # Add environment-specific values file
        local values_file="$DEPLOY_DIR/Kubernetes/helm/values-$ENVIRONMENT.yaml"
        if [[ -f "$values_file" ]]; then
            helm_args+=("--values" "$values_file")
        fi
        
        if [[ "$DRY_RUN" == "true" ]]; then
            helm_args+=("--dry-run")
        fi
        
        helm "${helm_args[@]}"
        
    else
        # Deploy using kubectl
        log_info "Deploying with kubectl..."
        
        if [[ -d "$DEPLOY_DIR/Kubernetes" ]]; then
            # Apply manifests
            local kubectl_args=("apply" "-f" "$DEPLOY_DIR/Kubernetes/")
            
            if [[ "$DRY_RUN" == "true" ]]; then
                kubectl_args+=("--dry-run=client")
            fi
            
            kubectl "${kubectl_args[@]}"
        else
            log_error "Kubernetes manifests not found"
            exit 1
        fi
    fi
    
    if [[ "$DRY_RUN" != "true" ]]; then
        # Wait for rollout to complete
        log_info "Waiting for deployment rollout..."
        kubectl rollout status deployment/"$PROJECT_NAME" -n "$NAMESPACE" --timeout=600s
        
        # Wait for services to be ready
        wait_for_health_check
    fi
    
    log_success "Kubernetes deployment completed"
}{{end}}

{{if .Components.Infrastructure.Terraform}}# Deploy using Terraform
deploy_terraform() {
    log_step "Deploying with Terraform..."
    
    cd "$DEPLOY_DIR/Terraform"
    
    # Initialize Terraform
    terraform init
    
    # Select or create workspace
    if terraform workspace list | grep -q "$ENVIRONMENT"; then
        terraform workspace select "$ENVIRONMENT"
    else
        terraform workspace new "$ENVIRONMENT"
    fi
    
    # Plan deployment
    log_info "Planning Terraform deployment..."
    local plan_file="/tmp/{{.Name}}-terraform-$ENVIRONMENT.plan"
    
    terraform plan \
        -var="environment=$ENVIRONMENT" \
        -var="version=$VERSION" \
        -var="replicas=$REPLICAS" \
        -out="$plan_file"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "DRY RUN: Terraform plan completed"
        terraform show "$plan_file"
        rm -f "$plan_file"
        return 0
    fi
    
    # Apply deployment
    log_info "Applying Terraform deployment..."
    terraform apply "$plan_file"
    
    # Clean up plan file
    rm -f "$plan_file"
    
    # Output important information
    terraform output
    
    cd "$PROJECT_ROOT"
    log_success "Terraform deployment completed"
}{{end}}

# Wait for health checks
wait_for_health_check() {
    log_step "Waiting for health checks..."
    
    local timeout="$HEALTH_CHECK_TIMEOUT"
    local interval=10
    local elapsed=0
    
    while [[ $elapsed -lt $timeout ]]; do
        case "$DEPLOY_METHOD" in
            docker)
                if check_docker_health; then
                    log_success "Health checks passed"
                    return 0
                fi
                ;;
            kubernetes|k8s)
                if check_kubernetes_health; then
                    log_success "Health checks passed"
                    return 0
                fi
                ;;
        esac
        
        log_info "Waiting for services to be healthy... ($elapsed/${timeout}s)"
        sleep $interval
        elapsed=$((elapsed + interval))
    done
    
    log_error "Health checks failed after ${timeout}s"
    return 1
}

# Check Docker health
check_docker_health() {
    local compose_file="docker-compose.$ENVIRONMENT.yml"
    
    if [[ -f "$compose_file" ]]; then
        # Check if all services are running
        local running_services=$(docker-compose -f "$compose_file" ps --services --filter "status=running" | wc -l)
        local total_services=$(docker-compose -f "$compose_file" ps --services | wc -l)
        
        if [[ $running_services -eq $total_services ]]; then
            return 0
        fi
    fi
    
    return 1
}

# Check Kubernetes health
check_kubernetes_health() {
    # Check if deployment is ready
    local ready_replicas=$(kubectl get deployment "$PROJECT_NAME" -n "$NAMESPACE" -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
    local desired_replicas=$(kubectl get deployment "$PROJECT_NAME" -n "$NAMESPACE" -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "0")
    
    if [[ "$ready_replicas" == "$desired_replicas" && "$ready_replicas" -gt 0 ]]; then
        return 0
    fi
    
    return 1
}

# Run post-deployment tests
run_post_deployment_tests() {
    log_step "Running post-deployment tests..."
    
    # Wait a bit for services to stabilize
    sleep 30
    
    case "$DEPLOY_METHOD" in
        docker)
            run_docker_smoke_tests
            ;;
        kubernetes|k8s)
            run_kubernetes_smoke_tests
            ;;
    esac
    
    log_success "Post-deployment tests passed"
}

# Run Docker smoke tests
run_docker_smoke_tests() {
    log_info "Running Docker smoke tests..."
    
{{if .Components.Backend.API}}    # Test backend health endpoint
    local backend_url="http://localhost:8080"
    if curl -f "$backend_url/health" >/dev/null 2>&1; then
        log_success "Backend health check passed"
    else
        log_error "Backend health check failed"
        return 1
    fi{{end}}
    
{{if .Components.Frontend.MainApp}}    # Test frontend
    local frontend_url="http://localhost:3000"
    if curl -f "$frontend_url" >/dev/null 2>&1; then
        log_success "Frontend health check passed"
    else
        log_error "Frontend health check failed"
        return 1
    fi{{end}}
}

# Run Kubernetes smoke tests
run_kubernetes_smoke_tests() {
    log_info "Running Kubernetes smoke tests..."
    
    # Get service endpoints
    local services=$(kubectl get services -n "$NAMESPACE" -o jsonpath='{.items[*].metadata.name}')
    
    for service in $services; do
        log_info "Testing service: $service"
        
        # Port forward to test service
        local port=$(kubectl get service "$service" -n "$NAMESPACE" -o jsonpath='{.spec.ports[0].port}')
        kubectl port-forward "service/$service" "$port:$port" -n "$NAMESPACE" &
        local pf_pid=$!
        
        sleep 5
        
        # Test health endpoint
        if curl -f "http://localhost:$port/health" >/dev/null 2>&1; then
            log_success "Service $service health check passed"
        else
            log_warning "Service $service health check failed"
        fi
        
        # Clean up port forward
        kill $pf_pid 2>/dev/null || true
    done
}

# Rollback deployment
rollback_deployment() {
    log_step "Rolling back deployment..."
    
    case "$DEPLOY_METHOD" in
        docker)
            rollback_docker_deployment
            ;;
        kubernetes|k8s)
            rollback_kubernetes_deployment
            ;;
        terraform)
            rollback_terraform_deployment
            ;;
    esac
    
    log_success "Rollback completed"
}

# Rollback Docker deployment
rollback_docker_deployment() {
    log_info "Rolling back Docker deployment..."
    
    local compose_file="docker-compose.$ENVIRONMENT.yml"
    
    if [[ -f "$compose_file" ]]; then
        # Get previous version from git
        local previous_version=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "previous")
        
        # Update image tags to previous version
        export VERSION="$previous_version"
        
        docker-compose -f "$compose_file" pull
        docker-compose -f "$compose_file" up -d
    fi
}

# Rollback Kubernetes deployment
rollback_kubernetes_deployment() {
    log_info "Rolling back Kubernetes deployment..."
    
    # Rollback using kubectl
    kubectl rollout undo deployment/"$PROJECT_NAME" -n "$NAMESPACE"
    kubectl rollout status deployment/"$PROJECT_NAME" -n "$NAMESPACE" --timeout=300s
}

# Rollback Terraform deployment
rollback_terraform_deployment() {
    log_info "Rolling back Terraform deployment..."
    
    cd "$DEPLOY_DIR/Terraform"
    
    # This is complex and depends on your Terraform setup
    # For now, just show the current state
    terraform show
    
    log_warning "Terraform rollback requires manual intervention"
    log_info "Please review the Terraform state and apply necessary changes"
}

# Show deployment summary
show_deployment_summary() {
    log_success "Deployment completed successfully!"
    echo ""
    echo -e "${CYAN}Deployment Summary:${NC}"
    echo "  Environment: $ENVIRONMENT"
    echo "  Version: $VERSION"
    echo "  Deploy Method: $DEPLOY_METHOD"
    echo "  Namespace: $NAMESPACE"
    echo "  Replicas: $REPLICAS"
    echo "  Deploy Time: $BUILD_TIME"
    echo ""
    
    case "$DEPLOY_METHOD" in
        docker)
            echo -e "${CYAN}Docker Services:${NC}"
            if [[ -f "docker-compose.$ENVIRONMENT.yml" ]]; then
                docker-compose -f "docker-compose.$ENVIRONMENT.yml" ps
            fi
            ;;
        kubernetes|k8s)
            echo -e "${CYAN}Kubernetes Resources:${NC}"
            kubectl get all -n "$NAMESPACE"
            echo ""
            echo -e "${CYAN}Service URLs:${NC}"
            kubectl get ingress -n "$NAMESPACE" -o custom-columns=NAME:.metadata.name,HOSTS:.spec.rules[*].host,PORTS:.spec.rules[*].http.paths[*].backend.service.port.number
            ;;
    esac
    
    echo ""
    echo -e "${GREEN}Deployment completed successfully! 🚀${NC}"
}

# Main deployment function
main() {
    echo -e "${CYAN}"
    echo "╔══════════════════════════════════════════════════════════════╗"
    echo "║                   {{.Name}} Deployment Script                  ║"
    echo "║                 Deploying to $ENVIRONMENT environment                 ║"
    echo "╚══════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    
    load_environment_config
    validate_prerequisites
    run_pre_deployment_tests
    build_application
    
    case "$DEPLOY_METHOD" in
        docker)
            deploy_docker
            ;;
        kubernetes|k8s)
            deploy_kubernetes
            ;;
        terraform)
            deploy_terraform
            ;;
        *)
            log_error "Unknown deployment method: $DEPLOY_METHOD"
            exit 1
            ;;
    esac
    
    run_post_deployment_tests
    show_deployment_summary
}

# Parse command line arguments
ENVIRONMENT=""
while [[ $# -gt 0 ]]; do
    case $1 in
        dev|development)
            ENVIRONMENT="development"
            shift
            ;;
        stage|staging)
            ENVIRONMENT="staging"
            shift
            ;;
        prod|production)
            ENVIRONMENT="production"
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --skip-tests)
            SKIP_TESTS=true
            shift
            ;;
        --skip-build)
            SKIP_BUILD=true
            shift
            ;;
        --force)
            FORCE_DEPLOY=true
            shift
            ;;
        --no-rollback)
            ROLLBACK_ON_FAILURE=false
            shift
            ;;
        --version)
            VERSION="$2"
            shift 2
            ;;
        --method)
            DEPLOY_METHOD="$2"
            shift 2
            ;;
        --help|-h)
            echo "{{.Name}} Deployment Script"
            echo ""
            echo "Usage: $0 [environment] [options]"
            echo ""
            echo "Environments:"
            echo "  dev, development      Deploy to development environment"
            echo "  stage, staging        Deploy to staging environment"
            echo "  prod, production      Deploy to production environment"
            echo ""
            echo "Options:"
            echo "  --dry-run             Perform a dry run without making changes"
            echo "  --skip-tests          Skip pre-deployment tests"
            echo "  --skip-build          Skip application build"
            echo "  --force               Force deployment (skip safety checks)"
            echo "  --no-rollback         Disable automatic rollback on failure"
            echo "  --version VERSION     Override version string"
            echo "  --method METHOD       Deployment method (docker|kubernetes|terraform)"
            echo "  --help, -h            Show this help message"
            echo ""
            echo "Environment Variables:"
            echo "  DRY_RUN               Perform dry run (true|false)"
            echo "  SKIP_TESTS            Skip tests (true|false)"
            echo "  SKIP_BUILD            Skip build (true|false)"
            echo "  FORCE_DEPLOY          Force deployment (true|false)"
            echo "  ROLLBACK_ON_FAILURE   Enable rollback on failure (true|false)"
            echo "  DEPLOY_METHOD         Deployment method"
            exit 0
            ;;
        *)
            if [[ -z "$ENVIRONMENT" ]]; then
                ENVIRONMENT="$1"
            else
                log_error "Unknown option: $1"
                exit 1
            fi
            shift
            ;;
    esac
done

# Set default environment if not provided
if [[ -z "$ENVIRONMENT" ]]; then
    ENVIRONMENT="$DEFAULT_ENVIRONMENT"
fi

# Validate environment
case "$ENVIRONMENT" in
    development|dev|staging|stage|production|prod)
        ;;
    *)
        log_error "Invalid environment: $ENVIRONMENT"
        log_error "Valid environments: development, staging, production"
        exit 1
        ;;
esac

# Run main deployment
main