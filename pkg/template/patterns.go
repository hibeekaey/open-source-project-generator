// Package template provides common template patterns and reusable components.
//
// This package consolidates common template patterns from various template files
// into reusable components that can be used across different template types.
package template

import (
	"fmt"
	"strings"
	"text/template"
	"time"
)

// CommonTemplatePatterns provides reusable template patterns
type CommonTemplatePatterns struct {
	patterns map[string]*template.Template
}

// NewCommonTemplatePatterns creates a new common template patterns instance
func NewCommonTemplatePatterns() *CommonTemplatePatterns {
	patterns := &CommonTemplatePatterns{
		patterns: make(map[string]*template.Template),
	}

	patterns.initializePatterns()
	return patterns
}

// initializePatterns sets up common template patterns
func (p *CommonTemplatePatterns) initializePatterns() {
	// File header pattern
	p.patterns["file_header"] = template.Must(template.New("file_header").Parse(`// Package {{.PackageName}} {{.Description}}
//
// {{.GeneratedAt}}
// Generated by Open Source Project Generator
package {{.PackageName}}
`))

	// Test file header pattern
	p.patterns["test_header"] = template.Must(template.New("test_header").Parse(`package {{.PackageName}}

import (
	"testing"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
)

// {{.TestSuiteName}}TestSuite provides test suite for {{.TestSuiteName}}
type {{.TestSuiteName}}TestSuite struct {
	suite.Suite
}

func (suite *{{.TestSuiteName}}TestSuite) SetupSuite() {
	// Setup test environment
}

func (suite *{{.TestSuiteName}}TestSuite) SetupTest() {
	// Setup for each test
}

func (suite *{{.TestSuiteName}}TestSuite) TearDownTest() {
	// Cleanup after each test
}

func (suite *{{.TestSuiteName}}TestSuite) TearDownSuite() {
	// Cleanup after all tests
}
`))

	// Database setup pattern
	p.patterns["database_setup"] = template.Must(template.New("database_setup").Parse(`// SetupTestDB creates an in-memory SQLite database for testing
func SetupTestDB() (*gorm.DB, error) {
	db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Silent),
	})
	if err != nil {
		return nil, err
	}

	// Run migrations
	err = db.AutoMigrate({{range .Models}}
		&{{.}}{},{{end}}
	)
	if err != nil {
		return nil, err
	}

	return db, nil
}

// CleanupTestDB cleans all data from test database
func CleanupTestDB(db *gorm.DB) error {
	// Delete all data in reverse order of dependencies
	{{range .CleanupQueries}}
	if err := db.Exec("{{.}}").Error; err != nil {
		return err
	}{{end}}
	return nil
}
`))

	// HTTP handler pattern
	p.patterns["http_handler"] = template.Must(template.New("http_handler").Parse(`// {{.HandlerName}} handles {{.Description}}
func {{.HandlerName}}(c *gin.Context) {
	// Extract request data
	var req {{.RequestType}}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Validate request
	if err := validate{{.RequestType}}(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Process request
	result, err := {{.ServiceMethod}}(req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Return response
	c.JSON(http.StatusOK, result)
}
`))

	// Service layer pattern
	p.patterns["service_layer"] = template.Must(template.New("service_layer").Parse(`// {{.ServiceName}} provides business logic for {{.Domain}}
type {{.ServiceName}} struct {
	{{range .Dependencies}}
	{{.Name}} {{.Type}}{{end}}
}

// New{{.ServiceName}} creates a new {{.ServiceName}}
func New{{.ServiceName}}({{range .Dependencies}}{{.Name}} {{.Type}}{{if not .Last}}, {{end}}{{end}}) *{{.ServiceName}} {
	return &{{.ServiceName}}{
		{{range .Dependencies}}
		{{.Name}}: {{.Name}},{{end}}
	}
}

// {{.MethodName}} {{.MethodDescription}}
func (s *{{.ServiceName}}) {{.MethodName}}({{.MethodParams}}) ({{.MethodReturns}}, error) {
	// Implementation here
	return {{.ReturnValues}}, nil
}
`))

	// Repository pattern
	p.patterns["repository"] = template.Must(template.New("repository").Parse(`// {{.RepositoryName}} provides data access for {{.Entity}}
type {{.RepositoryName}} struct {
	db *gorm.DB
}

// New{{.RepositoryName}} creates a new {{.RepositoryName}}
func New{{.RepositoryName}}(db *gorm.DB) *{{.RepositoryName}} {
	return &{{.RepositoryName}}{db: db}
}

// Create creates a new {{.Entity}}
func (r *{{.RepositoryName}}) Create({{.EntityLower}} *{{.Entity}}) error {
	return r.db.Create({{.EntityLower}}).Error
}

// GetByID retrieves {{.Entity}} by ID
func (r *{{.RepositoryName}}) GetByID(id uint) (*{{.Entity}}, error) {
	var {{.EntityLower}} {{.Entity}}
	err := r.db.First(&{{.EntityLower}}, id).Error
	return &{{.EntityLower}}, err
}

// Update updates an existing {{.Entity}}
func (r *{{.RepositoryName}}) Update({{.EntityLower}} *{{.Entity}}) error {
	return r.db.Save({{.EntityLower}}).Error
}

// Delete deletes {{.Entity}} by ID
func (r *{{.RepositoryName}}) Delete(id uint) error {
	return r.db.Delete(&{{.Entity}}{}, id).Error
}

// List retrieves all {{.Entity}}s with pagination
func (r *{{.RepositoryName}}) List(offset, limit int) ([]{{.Entity}}, error) {
	var {{.EntityLower}}s []{{.Entity}}
	err := r.db.Offset(offset).Limit(limit).Find(&{{.EntityLower}}s).Error
	return {{.EntityLower}}s, err
}
`))

	// Middleware pattern
	p.patterns["middleware"] = template.Must(template.New("middleware").Parse(`// {{.MiddlewareName}} provides {{.Description}}
func {{.MiddlewareName}}() gin.HandlerFunc {
	return gin.HandlerFunc(func(c *gin.Context) {
		// Pre-processing
		{{.PreProcessing}}

		// Continue to next handler
		c.Next()

		// Post-processing
		{{.PostProcessing}}
	})
}
`))

	// Configuration pattern
	p.patterns["config"] = template.Must(template.New("config").Parse(`// Config holds application configuration
type Config struct {
	{{range .Fields}}
	{{.Name}} {{.Type}} ` + "`" + `{{.Tags}}` + "`" + `{{end}}
}

// LoadConfig loads configuration from environment variables
func LoadConfig() *Config {
	return &Config{
		{{range .Fields}}
		{{.Name}}: getEnv("{{.EnvVar}}", "{{.Default}}"),{{end}}
	}
}

func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}
`))

	// Dockerfile pattern
	p.patterns["dockerfile"] = template.Must(template.New("dockerfile").Parse(`FROM {{.BaseImage}}

# Set working directory
WORKDIR /app

# Copy go mod files
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy source code
COPY . .

# Build the application
RUN go build -o {{.BinaryName}} ./cmd/{{.MainPackage}}

# Expose port
EXPOSE {{.Port}}

# Run the application
CMD ["./{{.BinaryName}}"]
`))

	// Docker Compose pattern
	p.patterns["docker_compose"] = template.Must(template.New("docker_compose").Parse(`version: '3.8'

services:
  {{.ServiceName}}:
    build: .
    ports:
      - "{{.Port}}:{{.Port}}"
    environment:
      {{range .Environment}}
      - {{.}}{{end}}
    depends_on:
      {{range .Dependencies}}
      - {{.}}{{end}}

  {{range .Dependencies}}
  {{.}}:
    image: {{.Image}}
    environment:
      {{range .Environment}}
      - {{.}}{{end}}
    volumes:
      {{range .Volumes}}
      - {{.}}{{end}}
  {{end}}
`))

	// Kubernetes deployment pattern
	p.patterns["k8s_deployment"] = template.Must(template.New("k8s_deployment").Parse(`apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{.Name}}
  labels:
    app: {{.Name}}
spec:
  replicas: {{.Replicas}}
  selector:
    matchLabels:
      app: {{.Name}}
  template:
    metadata:
      labels:
        app: {{.Name}}
    spec:
      containers:
      - name: {{.Name}}
        image: {{.Image}}
        ports:
        - containerPort: {{.Port}}
        env:
        {{range .Environment}}
        - name: {{.Name}}
          value: "{{.Value}}"{{end}}
        resources:
          requests:
            memory: "{{.MemoryRequest}}"
            cpu: "{{.CPURequest}}"
          limits:
            memory: "{{.MemoryLimit}}"
            cpu: "{{.CPULimit}}"
---
apiVersion: v1
kind: Service
metadata:
  name: {{.Name}}-service
spec:
  selector:
    app: {{.Name}}
  ports:
  - port: {{.Port}}
    targetPort: {{.Port}}
  type: LoadBalancer
`))

	// README pattern
	p.patterns["readme"] = template.Must(template.New("readme").Parse(`# {{.ProjectName}}

{{.Description}}

## Features

{{range .Features}}
- {{.}}{{end}}

## Installation

` + "```" + `bash
# Clone the repository
git clone {{.Repository}}
cd {{.ProjectName}}

# Install dependencies
{{.InstallCommand}}

# Run the application
{{.RunCommand}}
` + "```" + `

## Usage

{{.UsageInstructions}}

## API Documentation

{{.APIDocumentation}}

## Contributing

{{.ContributingInstructions}}

## License

{{.License}}
`))

	// Makefile pattern
	p.patterns["makefile"] = template.Must(template.New("makefile").Parse(`# {{.ProjectName}} Makefile

.PHONY: build test clean run docker

# Build the application
build:
	{{.BuildCommand}}

# Run tests
test:
	{{.TestCommand}}

# Clean build artifacts
clean:
	{{.CleanCommand}}

# Run the application
run:
	{{.RunCommand}}

# Build Docker image
docker:
	docker build -t {{.ImageName}} .

# Run with Docker Compose
docker-compose:
	docker-compose up -d

# Install dependencies
deps:
	{{.DepsCommand}}
`))
}

// GetPattern returns a template pattern by name
func (p *CommonTemplatePatterns) GetPattern(name string) *template.Template {
	return p.patterns[name]
}

// GetPatternNames returns all available pattern names
func (p *CommonTemplatePatterns) GetPatternNames() []string {
	names := make([]string, 0, len(p.patterns))
	for name := range p.patterns {
		names = append(names, name)
	}
	return names
}

// ExecutePattern executes a template pattern with data
func (p *CommonTemplatePatterns) ExecutePattern(name string, data interface{}) (string, error) {
	pattern, exists := p.patterns[name]
	if !exists {
		return "", fmt.Errorf("pattern %s not found", name)
	}

	var buf strings.Builder
	if err := pattern.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute pattern %s: %v", name, err)
	}

	return buf.String(), nil
}

// TemplateData provides common data for templates
type TemplateData struct {
	// Project information
	ProjectName string
	Description string
	Author      string
	Email       string
	Repository  string
	License     string
	GeneratedAt string

	// Package information
	PackageName string
	Domain      string

	// Technical details
	BaseImage   string
	Port        string
	BinaryName  string
	MainPackage string

	// Features and capabilities
	Features     []string
	Models       []string
	Environment  []EnvVar
	Dependencies []Dependency

	// Commands
	InstallCommand string
	RunCommand     string
	BuildCommand   string
	TestCommand    string
	CleanCommand   string
	DepsCommand    string

	// Documentation
	UsageInstructions        string
	APIDocumentation         string
	ContributingInstructions string
}

// EnvVar represents an environment variable
type EnvVar struct {
	Name  string
	Value string
}

// Dependency represents a service dependency
type Dependency struct {
	Name        string
	Type        string
	Image       string
	Environment []EnvVar
	Volumes     []string
}

// TestSuiteData provides data for test suite templates
type TestSuiteData struct {
	PackageName    string
	TestSuiteName  string
	Models         []string
	CleanupQueries []string
}

// HandlerData provides data for HTTP handler templates
type HandlerData struct {
	HandlerName   string
	Description   string
	RequestType   string
	ServiceMethod string
}

// ServiceData provides data for service layer templates
type ServiceData struct {
	ServiceName       string
	Domain            string
	MethodName        string
	MethodDescription string
	MethodParams      string
	MethodReturns     string
	ReturnValues      string
	Dependencies      []Dependency
}

// RepositoryData provides data for repository templates
type RepositoryData struct {
	RepositoryName string
	Entity         string
	EntityLower    string
}

// MiddlewareData provides data for middleware templates
type MiddlewareData struct {
	MiddlewareName string
	Description    string
	PreProcessing  string
	PostProcessing string
}

// ConfigData provides data for configuration templates
type ConfigData struct {
	Fields []ConfigField
}

// ConfigField represents a configuration field
type ConfigField struct {
	Name    string
	Type    string
	Tags    string
	EnvVar  string
	Default string
}

// DockerData provides data for Docker templates
type DockerData struct {
	BaseImage   string
	Port        string
	BinaryName  string
	MainPackage string
}

// DockerComposeData provides data for Docker Compose templates
type DockerComposeData struct {
	ServiceName  string
	Port         string
	Environment  []EnvVar
	Dependencies []Dependency
}

// K8sData provides data for Kubernetes templates
type K8sData struct {
	Name          string
	Image         string
	Port          string
	Replicas      int
	Environment   []EnvVar
	MemoryRequest string
	CPURequest    string
	MemoryLimit   string
	CPULimit      string
}

// READMEData provides data for README templates
type READMEData struct {
	ProjectName              string
	Description              string
	Repository               string
	Features                 []string
	InstallCommand           string
	RunCommand               string
	UsageInstructions        string
	APIDocumentation         string
	ContributingInstructions string
	License                  string
}

// MakefileData provides data for Makefile templates
type MakefileData struct {
	ProjectName  string
	ImageName    string
	BuildCommand string
	TestCommand  string
	CleanCommand string
	RunCommand   string
	DepsCommand  string
}

// Helper functions for common template operations

// GenerateFileHeader generates a file header
func (p *CommonTemplatePatterns) GenerateFileHeader(packageName, description string) (string, error) {
	data := TemplateData{
		PackageName: packageName,
		Description: description,
		GeneratedAt: time.Now().Format("2006-01-02 15:04:05"),
	}
	return p.ExecutePattern("file_header", data)
}

// GenerateTestSuite generates a test suite
func (p *CommonTemplatePatterns) GenerateTestSuite(packageName, suiteName string, models []string) (string, error) {
	data := TestSuiteData{
		PackageName:   packageName,
		TestSuiteName: suiteName,
		Models:        models,
		CleanupQueries: []string{
			"DELETE FROM user_roles",
			"DELETE FROM role_permissions",
			"DELETE FROM users",
			"DELETE FROM roles",
			"DELETE FROM permissions",
		},
	}
	return p.ExecutePattern("test_header", data)
}

// GenerateHTTPHandler generates an HTTP handler
func (p *CommonTemplatePatterns) GenerateHTTPHandler(handlerName, description, requestType, serviceMethod string) (string, error) {
	data := HandlerData{
		HandlerName:   handlerName,
		Description:   description,
		RequestType:   requestType,
		ServiceMethod: serviceMethod,
	}
	return p.ExecutePattern("http_handler", data)
}

// GenerateService generates a service layer
func (p *CommonTemplatePatterns) GenerateService(serviceName, domain, methodName, methodDescription string, dependencies []Dependency) (string, error) {
	data := ServiceData{
		ServiceName:       serviceName,
		Domain:            domain,
		MethodName:        methodName,
		MethodDescription: methodDescription,
		MethodParams:      "req interface{}",
		MethodReturns:     "interface{}, error",
		ReturnValues:      "result, nil",
		Dependencies:      dependencies,
	}
	return p.ExecutePattern("service_layer", data)
}

// GenerateRepository generates a repository
func (p *CommonTemplatePatterns) GenerateRepository(repositoryName, entity string) (string, error) {
	data := RepositoryData{
		RepositoryName: repositoryName,
		Entity:         entity,
		EntityLower:    strings.ToLower(entity),
	}
	return p.ExecutePattern("repository", data)
}

// GenerateMiddleware generates middleware
func (p *CommonTemplatePatterns) GenerateMiddleware(middlewareName, description, preProcessing, postProcessing string) (string, error) {
	data := MiddlewareData{
		MiddlewareName: middlewareName,
		Description:    description,
		PreProcessing:  preProcessing,
		PostProcessing: postProcessing,
	}
	return p.ExecutePattern("middleware", data)
}

// GenerateDockerfile generates a Dockerfile
func (p *CommonTemplatePatterns) GenerateDockerfile(baseImage, port, binaryName, mainPackage string) (string, error) {
	data := DockerData{
		BaseImage:   baseImage,
		Port:        port,
		BinaryName:  binaryName,
		MainPackage: mainPackage,
	}
	return p.ExecutePattern("dockerfile", data)
}

// GenerateREADME generates a README
func (p *CommonTemplatePatterns) GenerateREADME(projectName, description, repository string, features []string) (string, error) {
	data := READMEData{
		ProjectName:              projectName,
		Description:              description,
		Repository:               repository,
		Features:                 features,
		InstallCommand:           "go mod download",
		RunCommand:               "go run cmd/main.go",
		UsageInstructions:        "See the documentation for detailed usage instructions.",
		APIDocumentation:         "API documentation is available at /docs",
		ContributingInstructions: "Please read CONTRIBUTING.md for contribution guidelines.",
		License:                  "MIT",
	}
	return p.ExecutePattern("readme", data)
}
