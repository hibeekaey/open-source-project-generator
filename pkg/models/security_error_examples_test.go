package models

import (
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestExampleSecureFileOperation(t *testing.T) {
	t.Run("successful secure file operation", func(t *testing.T) {
		// Mock implementation that avoids actual file system operations
		testFile := "/tmp/test.txt"
		testData := []byte("test data")

		err := ExampleSecureFileOperation(testFile, testData)
		assert.NoError(t, err)
	})

	t.Run("dangerous directory path", func(t *testing.T) {
		dangerousPath := "/bin/malicious.txt"
		testData := []byte("malicious data")

		err := ExampleSecureFileOperation(dangerousPath, testData)
		assert.Error(t, err)
		assert.True(t, IsSecurityError(err))
		assert.Equal(t, SecuritySeverityHigh, GetSecuritySeverity(err))
	})

	t.Run("invalid path", func(t *testing.T) {
		invalidPath := "../../../etc/passwd"
		testData := []byte("malicious data")

		err := ExampleSecureFileOperation(invalidPath, testData)
		assert.Error(t, err)
		assert.True(t, IsSecurityError(err))
	})
}

func TestExampleSecureRandomGeneration(t *testing.T) {
	t.Run("successful random generation", func(t *testing.T) {
		length := 32
		randomBytes, err := ExampleSecureRandomGeneration(length)

		assert.NoError(t, err)
		assert.Len(t, randomBytes, length)

		// Verify randomness by generating another set and comparing
		randomBytes2, err := ExampleSecureRandomGeneration(length)
		assert.NoError(t, err)
		assert.NotEqual(t, randomBytes, randomBytes2, "Generated bytes should be different")
	})

	t.Run("invalid length parameter", func(t *testing.T) {
		randomBytes, err := ExampleSecureRandomGeneration(-1)

		assert.Error(t, err)
		assert.Nil(t, randomBytes)
		assert.True(t, IsSecurityError(err))
		assert.Equal(t, SecuritySeverityMedium, GetSecuritySeverity(err))
	})

	t.Run("zero length parameter", func(t *testing.T) {
		randomBytes, err := ExampleSecureRandomGeneration(0)

		assert.Error(t, err)
		assert.Nil(t, randomBytes)
		assert.True(t, IsSecurityError(err))
	})
}

func TestExampleErrorHandlingWithLogging(t *testing.T) {
	t.Run("handles security errors correctly", func(t *testing.T) {
		// Test with different security severity levels
		testCases := []struct {
			name     string
			severity SecuritySeverity
		}{
			{"critical error", SecuritySeverityCritical},
			{"high error", SecuritySeverityHigh},
			{"medium error", SecuritySeverityMedium},
			{"low error", SecuritySeverityLow},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				testErr := NewSecurityError(
					SecurityErrorType,
					tc.severity,
					"test",
					"test",
					"test error",
					nil,
				)

				operation := func() error {
					return testErr
				}

				err := ExampleErrorHandlingWithLogging(operation)
				assert.Error(t, err)
				assert.True(t, IsSecurityError(err))
				assert.Equal(t, tc.severity, GetSecuritySeverity(err))
			})
		}
	})

	t.Run("handles non-security errors", func(t *testing.T) {
		regularErr := errors.New("regular error")

		operation := func() error {
			return regularErr
		}

		err := ExampleErrorHandlingWithLogging(operation)
		assert.Error(t, err)
		assert.False(t, IsSecurityError(err))
		assert.Equal(t, regularErr, err)
	})

	t.Run("handles successful operations", func(t *testing.T) {
		operation := func() error {
			return nil
		}

		err := ExampleErrorHandlingWithLogging(operation)
		assert.NoError(t, err)
	})
}

func TestSecurityErrorContextPropagation(t *testing.T) {
	t.Run("error context is preserved through wrapping", func(t *testing.T) {
		baseErr := errors.New("base error")
		wrappedErr := WrapWithSecurityContext(
			baseErr,
			SecuritySeverityHigh,
			"test_component",
			"test_operation",
		)

		// Add additional context
		contextErr := wrappedErr.WithContext("file_path", "/test/path")
		contextErr = contextErr.WithContext("user_id", "test_user")

		assert.Equal(t, "/test/path", contextErr.Context["file_path"])
		assert.Equal(t, "test_user", contextErr.Context["user_id"])
		assert.Equal(t, baseErr, contextErr.Unwrap())
	})
}

func TestSecurityErrorRemediation(t *testing.T) {
	t.Run("predefined errors have remediation", func(t *testing.T) {
		predefinedErrors := []*SecurityOperationError{
			ErrInsufficientEntropy,
			ErrCryptographicFailure,
			ErrInvalidPath,
			ErrTempFileCreation,
			ErrAtomicWrite,
			ErrInsecurePermissions,
			ErrDangerousDirectory,
			ErrSecurityViolation,
			ErrUnauthorizedOperation,
		}

		for _, err := range predefinedErrors {
			assert.NotEmpty(t, err.Remediation, "Error %s should have remediation guidance", err.Error())
		}
	})

	t.Run("custom errors can have remediation added", func(t *testing.T) {
		err := NewSecurityError(
			SecurityErrorType,
			SecuritySeverityMedium,
			"test",
			"test",
			"test error",
			nil,
		).WithRemediation("Custom remediation guidance")

		assert.Equal(t, "Custom remediation guidance", err.Remediation)
	})
}

func TestMessageSanitizationInPractice(t *testing.T) {
	t.Run("sensitive information is sanitized", func(t *testing.T) {
		// Simulate an error message that might contain sensitive information
		longSensitiveMessage := "Security violation detected in file /home/user/.ssh/id_rsa with content: " +
			"-----BEGIN PRIVATE KEY----- very long sensitive content that should be truncated " +
			"to prevent information leakage in logs and error messages that might be exposed"

		err := NewSecurityError(
			SecurityErrorType,
			SecuritySeverityHigh,
			"file_scanner",
			"content_validation",
			longSensitiveMessage,
			nil,
		)

		errorMsg := err.Error()
		assert.True(t, len(errorMsg) <= 250, "Error message should be truncated")
		assert.Contains(t, errorMsg, "[message truncated for security]")
	})
}

func TestHelperFunctions(t *testing.T) {
	t.Run("isSecureFilePath", func(t *testing.T) {
		// Test valid paths
		validPaths := []string{
			"/tmp/test.txt",
			"/home/user/document.txt",
		}

		for _, path := range validPaths {
			result := isSecureFilePath(path)
			assert.True(t, result, "Path %s should be valid", path)
		}

		// Test invalid paths
		invalidPaths := []string{
			"../../../etc/passwd",
			"relative/path",
		}

		for _, path := range invalidPaths {
			result := isSecureFilePath(path)
			assert.False(t, result, "Path %s should be invalid", path)
		}
	})

	t.Run("isDangerousDirectory", func(t *testing.T) {
		dangerousDirs := []string{"/", "/bin", "/sbin", "/usr/bin", "/etc", "/root", "/boot"}
		for _, dir := range dangerousDirs {
			assert.True(t, isDangerousDirectory(dir), "Directory %s should be dangerous", dir)
		}

		safeDirs := []string{"/tmp", "/home/user", "/var/log"}
		for _, dir := range safeDirs {
			assert.False(t, isDangerousDirectory(dir), "Directory %s should be safe", dir)
		}
	})

	t.Run("generateSecureLogID", func(t *testing.T) {
		id1 := generateSecureLogID()
		id2 := generateSecureLogID()

		assert.NotEmpty(t, id1)
		assert.NotEmpty(t, id2)
		assert.NotEqual(t, id1, id2, "Generated IDs should be unique")
		assert.Len(t, id1, 16, "ID should be 16 hex characters (8 bytes)")
	})
}
